import { EventPayloads, WebhookEvent } from "@octokit/webhooks";
import merge from "deepmerge";
import type { Logger } from "pino";
import { ProbotOctokit } from "./octokit/probot-octokit";
import { DeprecatedLogger } from "./types";
import { WebhookEvents } from "@octokit/webhooks";
export declare type MergeOptions = merge.Options;
export interface WebhookPayloadWithRepository {
    [key: string]: any;
    repository?: EventPayloads.PayloadRepository;
    issue?: {
        [key: string]: any;
        number: number;
        html_url?: string;
        body?: string;
    };
    pull_request?: {
        [key: string]: any;
        number: number;
        html_url?: string;
        body?: string;
    };
    sender?: {
        [key: string]: any;
        type: string;
    };
    action?: string;
    installation?: {
        id: number;
        [key: string]: any;
    };
}
/**
 * The context of the event that was triggered, including the payload and
 * helpers for extracting information can be passed to GitHub API calls.
 *
 *  ```js
 *  module.exports = app => {
 *    app.on('push', context => {
 *      context.log.info('Code was pushed to the repo, what should we do with it?');
 *    });
 *  };
 *  ```
 *
 * @property {octokit} octokit - An Octokit instance
 * @property {payload} payload - The webhook event payload
 * @property {logger} log - A logger
 */
export declare class Context<E extends WebhookPayloadWithRepository = any> implements WebhookEvent<E> {
    name: WebhookEvents;
    id: string;
    payload: E;
    octokit: InstanceType<typeof ProbotOctokit>;
    log: DeprecatedLogger;
    constructor(event: WebhookEvent<E>, octokit: InstanceType<typeof ProbotOctokit>, log: Logger);
    /**
     * Return the `owner` and `repo` params for making API requests against a
     * repository.
     *
     * ```js
     * const params = context.repo({path: '.github/config.yml'})
     * // Returns: {owner: 'username', repo: 'reponame', path: '.github/config.yml'}
     * ```
     *
     * @param object - Params to be merged with the repo params.
     *
     */
    repo<T>(object?: T): {
        owner: string;
        repo: string;
    } & T;
    /**
     * Return the `owner`, `repo`, and `issue_number` params for making API requests
     * against an issue. The object passed in will be merged with the repo params.
     *
     *
     * ```js
     * const params = context.issue({body: 'Hello World!'})
     * // Returns: {owner: 'username', repo: 'reponame', issue_number: 123, body: 'Hello World!'}
     * ```
     *
     * @param object - Params to be merged with the issue params.
     */
    issue<T>(object?: T): {
        issue_number: any;
    } & {
        owner: string;
        repo: string;
    } & T;
    /**
     * Return the `owner`, `repo`, and `issue_number` params for making API requests
     * against an issue. The object passed in will be merged with the repo params.
     *
     *
     * ```js
     * const params = context.pullRequest({body: 'Hello World!'})
     * // Returns: {owner: 'username', repo: 'reponame', pull_number: 123, body: 'Hello World!'}
     * ```
     *
     * @param object - Params to be merged with the pull request params.
     */
    pullRequest<T>(object?: T): {
        pull_number: any;
    } & {
        owner: string;
        repo: string;
    } & T;
    /**
     * Returns a boolean if the actor on the event was a bot.
     * @type {boolean}
     */
    get isBot(): boolean;
    /**
     * Reads the app configuration from the given YAML file in the `.github`
     * directory of the repository.
     *
     * For example, given a file named `.github/config.yml`:
     *
     * ```yml
     * close: true
     * comment: Check the specs on the rotary girder.
     * ```
     *
     * Your app can read that file from the target repository:
     *
     * ```js
     * // Load config from .github/config.yml in the repository
     * const config = await context.config('config.yml')
     *
     * if (config.close) {
     *   context.octokit.issues.comment(context.issue({body: config.comment}))
     *   context.octokit.issues.edit(context.issue({state: 'closed'}))
     * }
     * ```
     *
     * You can also use a `defaultConfig` object:
     *
     * ```js
     * // Load config from .github/config.yml in the repository and combine with default config
     * const config = await context.config('config.yml', {comment: 'Make sure to check all the specs.'})
     *
     * if (config.close) {
     *   context.octokit.issues.comment(context.issue({body: config.comment}));
     *   context.octokit.issues.edit(context.issue({state: 'closed'}))
     * }
     * ```
     *
     * Config files can also specify a base that they extend. `deepMergeOptions` can be used
     * to configure how the target config, extended base, and default configs are merged.
     *
     * For security reasons, configuration is only loaded from the repository's default branch,
     * changes made in pull requests from different branches or forks are ignored.
     *
     * If you need more lower-level control over reading and merging configuration files,
     * you can `context.octokit.config.get(options)`, see https://github.com/probot/octokit-plugin-config.
     *
     * @param fileName - Name of the YAML file in the `.github` directory
     * @param defaultConfig - An object of default config options
     * @param deepMergeOptions - Controls merging configs (from the [deepmerge](https://github.com/TehShrike/deepmerge) module)
     * @return Configuration object read from the file
     */
    config<T>(fileName: string, defaultConfig?: T, deepMergeOptions?: MergeOptions): Promise<T | null>;
    /**
     * @deprecated `context.event` is deprecated, use `context.name` instead.
     */
    get event(): "installation" | "delete" | "error" | "status" | "*" | "check_run" | "check_run.completed" | "check_run.created" | "check_run.requested_action" | "check_run.rerequested" | "check_suite" | "check_suite.completed" | "check_suite.requested" | "check_suite.rerequested" | "code_scanning_alert" | "code_scanning_alert.appeared_in_branch" | "code_scanning_alert.closed_by_user" | "code_scanning_alert.created" | "code_scanning_alert.fixed" | "code_scanning_alert.reopened" | "code_scanning_alert.reopened_by_user" | "commit_comment" | "commit_comment.created" | "content_reference" | "content_reference.created" | "create" | "deploy_key" | "deploy_key.created" | "deploy_key.deleted" | "deployment" | "deployment.created" | "deployment_status" | "deployment_status.created" | "fork" | "github_app_authorization" | "github_app_authorization.revoked" | "gollum" | "installation.created" | "installation.deleted" | "installation.new_permissions_accepted" | "installation.suspend" | "installation.unsuspend" | "installation_repositories" | "installation_repositories.added" | "installation_repositories.removed" | "issue_comment" | "issue_comment.created" | "issue_comment.deleted" | "issue_comment.edited" | "issues" | "issues.assigned" | "issues.closed" | "issues.deleted" | "issues.demilestoned" | "issues.edited" | "issues.labeled" | "issues.locked" | "issues.milestoned" | "issues.opened" | "issues.pinned" | "issues.reopened" | "issues.transferred" | "issues.unassigned" | "issues.unlabeled" | "issues.unlocked" | "issues.unpinned" | "label" | "label.created" | "label.deleted" | "label.edited" | "marketplace_purchase" | "marketplace_purchase.cancelled" | "marketplace_purchase.changed" | "marketplace_purchase.pending_change" | "marketplace_purchase.pending_change_cancelled" | "marketplace_purchase.purchased" | "member" | "member.added" | "member.edited" | "member.removed" | "membership" | "membership.added" | "membership.removed" | "meta" | "meta.deleted" | "milestone" | "milestone.closed" | "milestone.created" | "milestone.deleted" | "milestone.edited" | "milestone.opened" | "organization" | "organization.deleted" | "organization.member_added" | "organization.member_invited" | "organization.member_removed" | "organization.renamed" | "org_block" | "org_block.blocked" | "org_block.unblocked" | "package" | "package.published" | "package.updated" | "page_build" | "ping" | "project_card" | "project_card.converted" | "project_card.created" | "project_card.deleted" | "project_card.edited" | "project_card.moved" | "project_column" | "project_column.created" | "project_column.deleted" | "project_column.edited" | "project_column.moved" | "project" | "project.closed" | "project.created" | "project.deleted" | "project.edited" | "project.reopened" | "public" | "pull_request" | "pull_request.assigned" | "pull_request.closed" | "pull_request.edited" | "pull_request.labeled" | "pull_request.locked" | "pull_request.merged" | "pull_request.opened" | "pull_request.ready_for_review" | "pull_request.reopened" | "pull_request.review_request_removed" | "pull_request.review_requested" | "pull_request.synchronize" | "pull_request.unassigned" | "pull_request.unlabeled" | "pull_request.unlocked" | "pull_request_review" | "pull_request_review.dismissed" | "pull_request_review.edited" | "pull_request_review.submitted" | "pull_request_review_comment" | "pull_request_review_comment.created" | "pull_request_review_comment.deleted" | "pull_request_review_comment.edited" | "push" | "release" | "release.created" | "release.deleted" | "release.edited" | "release.prereleased" | "release.published" | "release.released" | "release.unpublished" | "repository_dispatch" | "repository_dispatch.on-demand-test" | "repository" | "repository.archived" | "repository.created" | "repository.deleted" | "repository.edited" | "repository.privatized" | "repository.publicized" | "repository.renamed" | "repository.transferred" | "repository.unarchived" | "repository_import" | "repository_vulnerability_alert" | "repository_vulnerability_alert.create" | "repository_vulnerability_alert.dismiss" | "repository_vulnerability_alert.resolve" | "security_advisory" | "security_advisory.performed" | "security_advisory.published" | "security_advisory.updated" | "sponsorship" | "sponsorship.cancelled" | "sponsorship.created" | "sponsorship.edited" | "sponsorship.pending_cancellation" | "sponsorship.pending_tier_change" | "sponsorship.tier_changed" | "star" | "star.created" | "star.deleted" | "team" | "team.added_to_repository" | "team.created" | "team.deleted" | "team.edited" | "team.removed_from_repository" | "team_add" | "watch" | "watch.started" | "workflow_dispatch" | "workflow_run" | "workflow_run.action" | "workflow_run.completed" | "workflow_run.requested";
    /**
     * @deprecated `context.github` is deprecated. Use `context.octokit` instead.
     */
    get github(): {
        [x: string]: any;
    } & {
        [x: string]: any;
    } & import("@octokit/core").Octokit & void & {
        paginate: import("@octokit/plugin-paginate-rest").PaginateInterface;
    } & import("@octokit/plugin-rest-endpoint-methods/dist-types/generated/method-types").RestEndpointMethods & import("@probot/octokit-plugin-config/dist-types/types").API;
}
