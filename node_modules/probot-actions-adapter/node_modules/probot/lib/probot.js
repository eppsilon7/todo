"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Probot = void 0;
const deprecation_1 = require("deprecation");
const express_1 = __importDefault(require("express"));
const lru_cache_1 = __importDefault(require("lru-cache"));
const alias_log_1 = require("./helpers/alias-log");
const auth_1 = require("./auth");
const create_server_1 = require("./server/create-server");
const webhook_proxy_1 = require("./helpers/webhook-proxy");
const get_error_handler_1 = require("./helpers/get-error-handler");
const get_log_1 = require("./helpers/get-log");
const get_probot_octokit_with_defaults_1 = require("./octokit/get-probot-octokit-with-defaults");
const get_router_1 = require("./get-router");
const get_webhooks_1 = require("./octokit/get-webhooks");
const load_1 = require("./load");
const probot_octokit_1 = require("./octokit/probot-octokit");
const run_1 = require("./run");
const version_1 = require("./version");
const webhook_event_check_1 = require("./helpers/webhook-event-check");
const default_1 = require("./apps/default");
const defaultAppFns = [default_1.defaultApp];
class Probot {
    constructor(options = {}) {
        options.webhookPath = options.webhookPath || "/";
        options.secret = options.secret || "development";
        let logEnvVariableDeprecation;
        let level = options.logLevel;
        if (!options.log && !level && process.env.LOG_LEVEL) {
            logEnvVariableDeprecation =
                '[probot] "LOG_LEVEL" environment variable is deprecated. Use "new Probot({ logLevel })" instead';
            level = process.env.LOG_LEVEL;
        }
        this.log = alias_log_1.aliasLog(options.log || get_log_1.getLog({ level }));
        if (logEnvVariableDeprecation) {
            this.log.warn(new deprecation_1.Deprecation(logEnvVariableDeprecation));
        }
        if (options.id) {
            this.log.warn(new deprecation_1.Deprecation(`[probot] "id" option is deprecated. Use "appId" instead`));
            options.appId = options.appId || options.id;
        }
        if (options.cert) {
            this.log.warn(new deprecation_1.Deprecation(`[probot] "cert" option is deprecated. Use "privateKey" instead`));
            options.privateKey = options.privateKey || options.cert;
        }
        if (process.env.INSTALLATION_TOKEN_TTL) {
            this.log.warn('[probot] "INSTALLATION_TOKEN_TTL" environment variable is no longer used. Tokens are renewed as needed at the time of the request now.');
        }
        // TODO: support redis backend for access token cache if `options.redisConfig || process.env.REDIS_URL`
        const cache = new lru_cache_1.default({
            // cache max. 15000 tokens, that will use less than 10mb memory
            max: 15000,
            // Cache for 1 minute less than GitHub expiry
            maxAge: 1000 * 60 * 59,
        });
        const Octokit = get_probot_octokit_with_defaults_1.getProbotOctokitWithDefaults({
            githubToken: options.githubToken,
            Octokit: options.Octokit || probot_octokit_1.ProbotOctokit,
            appId: Number(options.appId),
            privateKey: options.privateKey,
            cache,
            log: this.log,
            redisConfig: options.redisConfig,
            throttleOptions: options.throttleOptions,
            baseUrl: options.baseUrl,
        });
        const octokit = new Octokit();
        this.state = {
            cache,
            githubToken: options.githubToken,
            log: this.log,
            Octokit,
            octokit,
            webhooks: {
                path: options.webhookPath,
                secret: options.secret,
            },
            appId: Number(options.appId),
            privateKey: options.privateKey,
            host: options.host,
            port: options.port,
            webhookProxy: options.webhookProxy,
        };
        this.auth = auth_1.auth.bind(null, this.state);
        this.webhooks = get_webhooks_1.getWebhooks(this.state);
        this.on = (eventNameOrNames, callback) => {
            // when an app subscribes to an event using `app.on(event, callback)`, Probot sends a request to `GET /app` and
            // verifies if the app is subscribed to the event and logs a warning if it is not.
            //
            // This feature will be moved out of Probot core as it has side effects and does not work in a stateless environment.
            webhook_event_check_1.webhookEventCheck(this.state, eventNameOrNames);
            if (eventNameOrNames === "*") {
                // @ts-ignore this workaround is only to surpress a warning. The `.on()` method will be deprecated soon anyway.
                return this.webhooks.onAny(callback);
            }
            return this.webhooks.on(eventNameOrNames, callback);
        };
        this.server = create_server_1.createServer({
            webhook: this.webhooks.middleware,
            logger: this.log,
        });
        this.version = version_1.VERSION;
        // TODO: remove once Application class was removed
        this.internalRouter = express_1.default.Router();
    }
    static async run(appFn) {
        const log = get_log_1.getLog({
            level: process.env.LOG_LEVEL,
            logFormat: process.env.LOG_FORMAT,
            logLevelInString: process.env.LOG_LEVEL_IN_STRING === "true",
            sentryDsn: process.env.SENTRY_DSN,
        });
        log.warn(new deprecation_1.Deprecation('[probot] "Probot.run" is deprecate. Import { run } from "probot" instead'));
        return run_1.run(appFn);
    }
    static defaults(defaults) {
        const ProbotWithDefaults = class extends this {
            constructor(...args) {
                const options = args[0] || {};
                super(Object.assign({}, defaults, options));
            }
        };
        return ProbotWithDefaults;
    }
    /**
     * @deprecated `probot.webhook` is deprecated. Use `probot.webhooks` instead
     */
    get webhook() {
        this.log.warn(new deprecation_1.Deprecation(`[probot] "probot.webhook" is deprecated. Use "probot.webhooks" instead`));
        return this.webhooks;
    }
    receive(event) {
        this.log.debug({ event }, "Webhook received");
        return this.webhooks.receive(event);
    }
    load(appFn) {
        if (typeof appFn === "string") {
            this.log.warn(new deprecation_1.Deprecation(`[probot] passing a string to "probot.load()" is deprecated. Pass the function from "${appFn}" instead.`));
        }
        const router = express_1.default.Router();
        // Connect the router from the app to the server
        this.server.use(router);
        // Initialize the ApplicationFunction
        load_1.load(this, router, appFn);
        return this;
    }
    setup(appFns) {
        this.log.warn(new deprecation_1.Deprecation(`[probot] "probot.setup()" is deprecated. Use the new "Server" class instead:
    
    const { Server, Probot } = require("probot")
    const server = new Server({
      // optional:
      host,
      port,
      webhookPath,
      webhookProxy,
      Probot: Probot.defaults({ id, privateKey, ... })
    })

    // load probot app function
    await server.load(app => {})

    // start listening to requests
    await server.start()
    // stop server with: await server.stop()

If you have more than one app function, combine them in a function instead

    const app1 = require("./app1")
    const app2 = require("./app2")

    module.exports = function app ({ probot, getRouter }) {
      await app1({ probot, getRouter })
      await app2({ probot, getRouter })
    }
`));
        // Log all unhandled rejections
        process.on("unhandledRejection", get_error_handler_1.getErrorHandler(this.log));
        // Load the given appFns along with the default ones
        appFns.concat(defaultAppFns).forEach((appFn) => this.load(appFn));
    }
    start() {
        this.log.warn(new deprecation_1.Deprecation(`[probot] "probot.start()" is deprecated. Use the new "Server" class instead:
    
    const { Server, Probot } = require("probot")
    const server = new Server({ 
      // optional:
      host,
      port,
      webhookPath,
      webhookProxy,
      Probot: Probot.defaults({ id, privateKey, ... })
    })

    // load probot app function
    await server.load(app => {})

    // start listening to requests
    await server.start()
    // stop server with: await server.stop()
`));
        this.log.info(`Running Probot v${this.version} (Node.js: ${process.version})`);
        const port = this.state.port || 3000;
        const { host, webhookProxy } = this.state;
        const webhookPath = this.state.webhooks.path;
        const printableHost = host !== null && host !== void 0 ? host : "localhost";
        this.httpServer = this.server
            .listen(port, ...(host ? [host] : []), () => {
            if (webhookProxy) {
                webhook_proxy_1.createWebhookProxy({
                    logger: this.log,
                    path: webhookPath,
                    port: port,
                    url: webhookProxy,
                });
            }
            this.log.info(`Listening on http://${printableHost}:${port}`);
        })
            .on("error", (error) => {
            if (error.code === "EADDRINUSE") {
                this.log.error(`Port ${port} is already in use. You can define the PORT environment variable to use a different port.`);
            }
            else {
                this.log.error(error);
            }
            process.exit(1);
        });
        return this.httpServer;
    }
    stop() {
        if (!this.httpServer)
            return;
        this.httpServer.close();
    }
    /**
     * Get an {@link http://expressjs.com|express} router that can be used to
     * expose HTTP endpoints
     *
     * ```
     * module.exports = (app, { getRouter }) => {
     *   // Get an express router to expose new HTTP endpoints
     *   const router = getRouter('/my-app');
     *
     *   // Use any middleware
     *   router.use(require('express').static(__dirname + '/public'));
     *
     *   // Add a new route
     *   router.get('/hello-world', (req, res) => {
     *     res.end('Hello World');
     *   });
     * };
     * ```
     *
     * @param path - the prefix for the routes* @param path
     *
     * @deprecated "app.route()" is deprecated, use the "getRouter()" argument from the app function instead: "(app, { getRouter }) => { ... }"
     */
    route(path) {
        this.log.warn(new deprecation_1.Deprecation(`[probot] "app.route()" is deprecated, use the "getRouter()" argument from the app function instead: "(app, { getRouter }) => { ... }"`));
        return get_router_1.getRouter(this.internalRouter, path);
    }
    /**
     * @deprecated use probot.log instead
     */
    get logger() {
        this.log.warn(new deprecation_1.Deprecation(`[probot] "probot.logger" is deprecated. Use "probot.log" instead`));
        return this.log;
    }
    /**
     * @deprecated "app.router" is deprecated, use "getRouter()" from the app function instead: "(app, { getRouter }) => { ... }"
     */
    get router() {
        this.log.warn(new deprecation_1.Deprecation(`[probot] "app.router" is deprecated, use "getRouter()" from the app function instead: "(app, { getRouter }) => { ... }"`));
        return this.internalRouter;
    }
}
exports.Probot = Probot;
Probot.version = version_1.VERSION;
//# sourceMappingURL=probot.js.map